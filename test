  public interface IExtendedProperty
    {
        string UniqueName { get; }
        bool IsValueSet { get; set; }
        object Value { get; set; }
        object ActualValue { get; }

    }

    public interface IExtendedProperty<T> : IExtendedProperty
    {
        new T Value { get; set; }
        new T ActualValue { get; }
    }

    using System;
using SquaredInfinity.Foundation.Extensions;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApplication31.PropertySystem
{
    public class CollectionExtendedProperty<TItem> : ExtendedProperty<Collection<TItem>>
    {
        CollectionInheritanceMode _inheritanceMode = CollectionInheritanceMode.Merge;
        public CollectionInheritanceMode InheritanceMode
        {
            get { return _inheritanceMode; }
            set { _inheritanceMode = value; }
        }

        public CollectionExtendedProperty(IExtendedPropertyCollection owner, string uniqueName, Func<Collection<TItem>> getDefaultValue)
            : this(owner, uniqueName, getDefaultValue, CollectionInheritanceMode.Merge)
        { }

        public CollectionExtendedProperty(IExtendedPropertyCollection owner, string uniqueName, Func<Collection<TItem>> getDefaultValue, CollectionInheritanceMode inheritanceMode)
             : base(owner, uniqueName, getDefaultValue)
        {
            this.InheritanceMode = inheritanceMode;
        }

        protected override Collection<TItem> GetActualValue()
        {
            if (IsValueSet)
            {
                if(InheritanceMode == CollectionInheritanceMode.Replace)
                    return Value;
                else
                {
                    object inheritedValue = null;
                    if (Owner.TryGetInheritedPropertyValue(UniqueName, out inheritedValue))
                    {
                        if(Value == null)
                        {
                            if(inheritedValue == null)
                            {
                                return GetDefaultValue();
                            }
                            else
                            {
                                return Value;
                            }
                        }
                        else
                        {
                            if (inheritedValue == null)
                            {
                                return Value;
                            }
                            else
                            {
                                var result = new Collection<TItem>();

                                result.AddRange((IEnumerable<TItem>)inheritedValue);

                                result.AddRange((IEnumerable<TItem>)Value);

                                return result;
                            }
                        }
                    }
                    else
                    {
                        return Value;
                    }
                }
            }
            else
            {
                object inheritedValue = null;
                if (Owner.TryGetInheritedPropertyValue(UniqueName, out inheritedValue))
                {
                    return (Collection<TItem>)inheritedValue;
                }
                else
                {
                    return GetDefaultValue();
                }
            }
        }
    }
}

    public enum CollectionInheritanceMode
    {
        Merge = 0,
        Replace,
        Default = Merge
    }
    
     public class ExtendedProperty<T> : NotifyPropertyChangedObject, IExtendedProperty<T>
    {
        string _uniqueName;
        public string UniqueName
        {
            get { return _uniqueName; }
            private set { _uniqueName = value; }
        }

        public IExtendedPropertyCollection Owner { get; private set; }

        bool _isValueSet = false;
        /// <summary>
        /// True if a value of this property is set.
        /// False if value is not set, in which case inherited value will be used (or a default value if inherited value is not set)
        /// </summary>
        public bool IsValueSet
        {
            get { return _isValueSet; }
            set 
            {
                if(TrySetThisPropertyValue(ref _isValueSet, value))
                {
                    RaisePropertyChanged(() => ActualValue);
                }
            }
        }

        T _value;
        public T Value
        {
            get { return _value; }
            set
            {
                TrySetThisPropertyValue(ref _value, value);
                
                IsValueSet = true;
            }
        }

        public T ActualValue
        {
            get
            {
                return GetActualValue();
            }
        }

        protected virtual T GetActualValue()
        {
            if (IsValueSet)
            {
                return Value;
            }
            else
            {
                object inheritedValue = null;
                if (Owner.TryGetInheritedPropertyValue(UniqueName, out inheritedValue))
                {
                    return (T)inheritedValue;
                }
                else
                {
                    return GetDefaultValue();
                }
            }
        }

        protected Func<T> GetDefaultValue { get; private set; }

        public ExtendedProperty(IExtendedPropertyCollection owner, string uniqueName, Func<T> getDefaultValue)
        {
            this.Owner = owner;
            this.UniqueName = uniqueName;
            this.Value = getDefaultValue();
            // using default value, do not mark Value as set.
            this.IsValueSet = false;
            this.GetDefaultValue = getDefaultValue;
        }


        object IExtendedProperty.Value
        {
            get { return this.Value; }
            set { this.Value = (T)value; }
        }

        object IExtendedProperty.ActualValue
        {
            get { return this.ActualValue; }
        }
    }
    
     public class ExtendedPropertyCollection : IExtendedPropertyCollection
    {
        readonly Dictionary<string, IExtendedProperty> Properties = new Dictionary<string, IExtendedProperty>();

        public IExtendedPropertyContainer Owner { get; private set; }

        public bool TryGetActualPropertyValue(string uniqueName, out object value)
        {
            var prop = (IExtendedProperty)null;

            if(Properties.TryGetValue(uniqueName, out prop))
            {
                value = prop.ActualValue;
                return true;
            }
            else
            {
                value = null;
                return false;
            }
        }

        public bool TryGetInheritedPropertyValue(string uniqueName, out object inheritedValue)
        {
            //var prop = (IExtendedProperty)null;

            if (Owner.TryGetInheritedPropertyValue(uniqueName, out inheritedValue))
            {
                return true;
            }
            else
            {
                return false;
            }

            //if (Properties.TryGetValue(uniqueName, out prop))
            //{
            //    if (prop.IsValueSet)
            //    {
            //        inheritedValue = prop.Value;
            //        return true;
            //    }
            //    else
            //    {
            //        if (Owner.TryGetInheritedPropertyValue(uniqueName, out inheritedValue))
            //        {
            //            return true;
            //        }
            //        else
            //        {
            //            return false;
            //        }
            //    }
            //}
            //else
            //{
            //    inheritedValue = null;
            //    return false;
            //}
        }

        public ExtendedPropertyCollection(IExtendedPropertyContainer owner)
        {
            this.Owner = owner;
        }

        public IExtendedProperty<T> RegisterProperty<T>(string uniqueName)
        {
            var p = new ExtendedProperty<T>(this, uniqueName, () => default(T));
            Properties.Add(uniqueName, p);
            return p;
        }

        public IExtendedProperty<T> RegisterProperty<T>(string uniqueName, Func<T> getDefaultValue)
        {
            var p = new ExtendedProperty<T>(this, uniqueName, getDefaultValue);
            Properties.Add(uniqueName, p);
            return p;
        }

        public CollectionExtendedProperty<TItem> RegisterCollectionProperty<TItem>(string uniqueName, Func<Collection<TItem>> getDefaultValue)
        {
            var p = new CollectionExtendedProperty<TItem>(this, uniqueName, getDefaultValue);
            Properties.Add(uniqueName, p);
            return p;
        }


        public IExtendedProperty this[string uniqueName]
        {
            get 
            {
                var prop = (IExtendedProperty) null;
                
                if(Properties.TryGetValue(uniqueName, out prop))
                {
                    return prop;
                }
                else
                {
                    throw new ArgumentException("Property with unique name '{0}' does not exist.".FormatWith(uniqueName));
                }
            }
        }
    }
    
        public abstract class ExtendedPropertyContainer : IExtendedPropertyContainer
    {
        public IExtendedPropertyContainer Parent { get; set; }

        IExtendedPropertyCollection _extendedProperties;
        public IExtendedPropertyCollection ExtendedProperties
        {
            get { return _extendedProperties; }
        }

        public virtual bool TryGetInheritedPropertyValue(string uniqueName, out object inheritedValue)
        {
            if (Parent == null)
            {
                inheritedValue = null;
                return false;
            }
            else
            {
                if(Parent.TryGetActualPropertyValue(uniqueName, out inheritedValue))
                {
                    return true;
                }

                return false;
            }
        }

        public virtual bool TryGetActualPropertyValue(string uniqueName, out object actualValue)
        {
            return ExtendedProperties.TryGetActualPropertyValue(uniqueName, out actualValue);
        }

        public ExtendedPropertyContainer()
        {
            _extendedProperties = new ExtendedPropertyCollection(this);
        }
    }
    
        public interface IExtendedPropertyCollection
    {
        /// <summary>
        /// Gets value of a property from inheritance tree.
        /// This collection will not be checked for the property, only property containers above in inheritance tree will.
        /// </summary>
        /// <param name="uniqueName"></param>
        /// <param name="inheritedValue"></param>
        /// <returns></returns>
        bool TryGetInheritedPropertyValue(string uniqueName, out object inheritedValue);

        /// <summary>
        /// Gets the actual value of requested property.
        /// If property exists in this collection and its value is set, then that value will be returned.
        /// If property does not exist in this collection or exists but its value is not set, then inheritace tree will be walked up until a value is found.
        /// </summary>
        /// <param name="uniqueName"></param>
        /// <param name="value"></param>
        /// <returns>True if property with set value could be found, false otherwise.</returns>
        bool TryGetActualPropertyValue(string uniqueName, out object value);

        IExtendedProperty<T> RegisterProperty<T>(string uniqueName);
        IExtendedProperty<T> RegisterProperty<T>(string uniqueName, Func<T> getDefaultValue);


        CollectionExtendedProperty<TItem> RegisterCollectionProperty<TItem>(string uniqueName, Func<Collection<TItem>> getDefaultValue);

        IExtendedProperty this[string uniqueName] { get; }
    }

  public interface IExtendedPropertyContainer
    {
        IExtendedPropertyContainer Parent { get; set; }

        IExtendedPropertyCollection ExtendedProperties { get; }

        /// <summary>
        /// Gets value of a property from inheritance tree.
        /// This container and its children will not be checked for the property, only property containers above in inheritance tree will.
        /// </summary>
        /// <param name="uniqueName"></param>
        /// <param name="inheritedValue"></param>
        /// <returns></returns>
        bool TryGetInheritedPropertyValue(string uniqueName, out object inheritedValue);

        /// <summary>
        /// Gets the actual value of requested property.
        /// If property exists in this container and its value is set, then that value will be returned.
        /// If property does not exist in this container or exists but its value is not set, then inheritace tree will be walked up until a value is found.
        /// </summary>
        /// <param name="uniqueName"></param>
        /// <param name="value"></param>
        /// <returns>True if property with set value could be found, false otherwise.</returns>
        bool TryGetActualPropertyValue(string uniqueName, out object actualValue);
    }


[TestClass]
    public class FileAccessTests
    {
        [TestMethod]
        public void MyTestMethod()
        {
            int count = 500;

            var defp = new RetryPolicy();

            defp.DefaultTransientFaultFilters.Add(
                new DynamicTransientFaultFilter<IOException>(ex => true));

            RetryPolicy.SetDefaultPolict(defp);

            Parallel.For(0, 1000, (x) =>
                {
                    if (x % 2 == 0)
                    {
                        string s = null;
                        if (!TryRead(out s))
                        {
                            Trace.WriteLine("Failed Read");
                        }
                        else
                        {
                            Trace.WriteLine("Read " + s);
                        }
                    }
                    else
                    {
                        var local_count = Interlocked.Decrement(ref count);

                        var s = local_count + " : " + new string((char)new Random().Next('a', 'z'), local_count);

                        if (!TryWrite(s))
                        {
                            Trace.WriteLine("Failed Write");
                        }
                        else
                        {
                            Trace.WriteLine("Wrote " + s);
                        }
                    }
                });
        }

        public bool TryRead(out string txt)
        {
            if (File.Exists("1.txt"))
            {
                var localTxt = (string)null;

                if(RetryPolicy.Default.Execute(() =>
                    {
                        // get read lock on a file
                        using (var fs = File.Open("1.txt", FileMode.Open, FileAccess.Read, FileShare.Read))
                        {
                            using (var sr = new StreamReader(fs))
                            {
                                localTxt = sr.ReadToEnd();
                                return true;
                            }
                        }
                    }))
                {
                    txt = localTxt;
                    return true;
                }
            }

            txt = null;
            return false;
        }

        public bool TryWrite(string txt)
        {
            return RetryPolicy.Default.Execute(() =>
                {
                    // get write lock on a file
                    using (var fs = File.Open("1.txt", FileMode.OpenOrCreate, FileAccess.Write, FileShare.None))
                    {
                        fs.SetLength(0);

                        using (var sw = new StreamWriter(fs))
                        {
                            sw.Write(txt);
                            return true;
                        }
                    }
                });
        }
    }

    public class TestContainer : ExtendedPropertyContainer
    {
        public string Name { get; set; }

        public IExtendedProperty<string> ToolTip { get; private set; }

        public IExtendedProperty<int> Count { get; private set; }

        public CollectionExtendedProperty<int> Items { get; private set; }

        public TestContainer()
        {
            ToolTip = ExtendedProperties.RegisterProperty<string>("ToolTip", () => "[UNSET]");
            Count = ExtendedProperties.RegisterProperty<int>("Count", () => 69);
            Items = ExtendedProperties.RegisterCollectionProperty("Items", () => new Collection<int>());
        }
    }

    [TestClass]
    public class UnitTest1
    {
        [TestMethod]
        public void ExtendedPropertyCanBeRegistered()
        {
            var tc = new TestContainer();

            tc.ExtendedProperties.RegisterProperty<int>("Grid.Row");

            tc.Count.Value++;

            tc.ExtendedProperties["Grid.Row"].Value = 3;

            // default of Count is 69, + 1 == 70
            Assert.AreEqual(70, tc.Count.ActualValue);

            Assert.AreEqual(3, tc.ExtendedProperties["Grid.Row"].ActualValue);
        }

        [TestMethod]
        public void ValueOfExtendedPropertyCanBeInherited()
        {
            // leaf
            var tc = new TestContainer { Name = "1" };

            // parent
            var parentTC = new TestContainer { Name = "Parent" };
            tc.Parent = parentTC;

            // grand parent
            var grandParentTC = new TestContainer { Name = "Parent" };
            parentTC.Parent = grandParentTC;

            tc.Count.Value = 1;
            parentTC.Count.Value = 13;
            grandParentTC.Count.Value = 69;

            tc.Count.IsValueSet = false;
            parentTC.Count.IsValueSet = false;
            Assert.AreEqual(69, tc.Count.ActualValue);
            Assert.AreEqual(69, parentTC.Count.ActualValue);
            Assert.AreEqual(69, grandParentTC.Count.ActualValue);

            tc.Count.IsValueSet = false;
            parentTC.Count.IsValueSet = true;
            Assert.AreEqual(13, tc.Count.ActualValue);
            Assert.AreEqual(13, parentTC.Count.ActualValue);
            Assert.AreEqual(69, grandParentTC.Count.ActualValue);


            tc.Count.IsValueSet = true;
            parentTC.Count.IsValueSet = false;
            Assert.AreEqual(1, tc.Count.ActualValue);
            Assert.AreEqual(69, parentTC.Count.ActualValue);
            Assert.AreEqual(69, grandParentTC.Count.ActualValue);


            tc.Count.IsValueSet = true;
            parentTC.Count.IsValueSet = true;
            Assert.AreEqual(1, tc.Count.ActualValue);
            Assert.AreEqual(13, parentTC.Count.ActualValue);
            Assert.AreEqual(69, grandParentTC.Count.ActualValue);
        }


        [TestMethod]
        public void DefaultValueIsSetAndReturnedAsActualValueIfNoInheritance()
        {
            var tc = new TestContainer();

            Assert.AreEqual("[UNSET]", tc.ToolTip.ActualValue);
        }

        [TestMethod]
        public void DefaultValueIsSetAndReturnedAsValue()
        {
            var tc = new TestContainer();

            Assert.AreEqual("[UNSET]", tc.ToolTip.Value);
        }

    }

    [TestClass]
    public class CollectionExtendedPropertyTests
    {
        [TestMethod]
        public void CanMergeInheritedCollectionItems()
        {
            var tc_parent = new TestContainer() { Name = "Parent" };
            tc_parent.Items.Value.Add(1);
            tc_parent.Items.Value.Add(2);
            tc_parent.Items.Value.Add(3);
            tc_parent.Items.IsValueSet = true;

            var tc = new TestContainer() { Name = "Child" };
            tc.Parent = tc_parent;
            tc.Items.Value.Add(4);
            tc.Items.Value.Add(5);
            tc.Items.Value.Add(6);
            tc.Items.IsValueSet = true;
            tc.Items.InheritanceMode = CollectionInheritanceMode.Replace;

            var x = tc.Items.ActualValue;
        }
    }

    [TestClass]
    public class ExtendedPropertyTests
    {
        [TestMethod]
        public void SettingValue_MarksValueAsSet()
        {
            var tc = new TestContainer();

            Assert.IsFalse(tc.Count.IsValueSet);

            tc.Count.Value = 13;

            Assert.AreEqual(13, tc.Count.Value);
            Assert.IsTrue(tc.Count.IsValueSet);
        }

        #region No Parent

        [TestMethod]
        public void ValueIsNotSet_And_NoParent__TryGetInheritedPropertyValueReturnsFalse()
        {
            var tc = new TestContainer();

            var val = (object) null;
            var res = tc.TryGetInheritedPropertyValue(tc.Count.UniqueName, out val);

            Assert.IsNull(val);
            Assert.IsFalse(res);
        }

        [TestMethod]
        public void ValueIsSet_And_NoParent__TryGetInheritedPropertyValueReturnsFalse()
        {
            var tc = new TestContainer();

            tc.Count.Value = 13;

            var val = (object)null;
            var res = tc.TryGetInheritedPropertyValue(tc.Count.UniqueName, out val);

            Assert.IsNull(val);
            Assert.IsFalse(res);
        }

        [TestMethod]
        public void ValueIsNotSet_And_NoParent__TryGetActualPropertyValueReturnsTrue_And_DefaultValue()
        {
            var tc = new TestContainer();

            var val = (object)null;
            var res = tc.TryGetActualPropertyValue(tc.Count.UniqueName, out val);

            Assert.AreEqual(69, val);
            Assert.IsTrue(res);
        }

        [TestMethod]
        public void ValueIsSet_And_NoParent__TryGetActualPropertyValueReturnsTrue()
        {
            var tc = new TestContainer();

            tc.Count.Value = 13;

            var val = (object)null;
            var res = tc.TryGetActualPropertyValue(tc.Count.UniqueName, out val);

            Assert.AreEqual(13, val);
            Assert.IsTrue(res);
        }

        #endregion

        #region Has Parent

        [TestMethod]
        public void ValueIsNotSet_And_HasParent__TryGetInheritedPropertyValueReturnsFalse()
        {
            var tc = new TestContainer();

            var val = (object)null;
            var res = tc.TryGetInheritedPropertyValue(tc.Count.UniqueName, out val);

            Assert.IsNull(val);
            Assert.IsFalse(res);
        }

        [TestMethod]
        public void ValueIsSet_And_HasParent__TryGetInheritedPropertyValueReturnsFalse()
        {
            var tc = new TestContainer();

            tc.Count.Value = 13;

            var val = (object)null;
            var res = tc.TryGetInheritedPropertyValue(tc.Count.UniqueName, out val);

            Assert.IsNull(val);
            Assert.IsFalse(res);
        }

        [TestMethod]
        public void ValueIsNotSet_And_HasParent__TryGetActualPropertyValueReturnsTrue_And_DefaultValue()
        {
            var tc = new TestContainer();

            var val = (object)null;
            var res = tc.TryGetActualPropertyValue(tc.Count.UniqueName, out val);

            Assert.AreEqual(69, val);
            Assert.IsTrue(res);
        }

        [TestMethod]
        public void ValueIsSet_And_HasParent__TryGetActualPropertyValueReturnsTrue()
        {
            var tc = new TestContainer();

            tc.Count.Value = 13;

            var val = (object)null;
            var res = tc.TryGetActualPropertyValue(tc.Count.UniqueName, out val);

            Assert.AreEqual(13, val);
            Assert.IsTrue(res);
        }

        #endregion
    }



    public class RetryPolicy
    {
        Random Rand = new Random();

        const int Default_MaxRetryAttempts = 10;
        const int Default_MinRetryDelayInMiliseconds = 50;
        const int Default_MaxRetryDelayInMiliseconds = 100;

        static RetryPolicy _defaultPolicy;
        public static RetryPolicy Default { get { return _defaultPolicy; } }

        public static void SetDefaultPolict(RetryPolicy newDefaultPolicy)
        {
            _defaultPolicy = newDefaultPolicy;
        }

        static RetryPolicy()
        {
            var dp = new RetryPolicy();

            // treat all exceptions as transient by default
            dp.DefaultTransientFaultFilters.Add(new DynamicTransientFaultFilter<Exception>(ex => true));

            _defaultPolicy = dp;
        }

        public List<ITransientFaultFilter> DefaultTransientFaultFilters { get; private set; }

        public RetryPolicy()
        {
            DefaultTransientFaultFilters = new List<ITransientFaultFilter>();
        }

        public void Execute(Action action)
        {
            Execute(action, null);
        }

        public void Execute(Action action, IReadOnlyList<ITransientFaultFilter> transientFaultFilters)
        {
            Execute(() =>
            {
                action();
                return true;
            },
                Default_MaxRetryAttempts,
                Default_MinRetryDelayInMiliseconds,
                Default_MaxRetryDelayInMiliseconds,
                transientFaultFilters);
        }

        public TResult Execute<TResult>(Func<TResult> func)
        {
            return Execute(
                func,
                Default_MaxRetryAttempts,
                Default_MinRetryDelayInMiliseconds,
                Default_MaxRetryDelayInMiliseconds,
                DefaultTransientFaultFilters);
        }

        public TResult Execute<TResult>(
            Func<TResult> func,
            int maxRetryAttempts,
            int minDelayInMiliseconds,
            int maxDelayInMiliseconds,
            IReadOnlyList<ITransientFaultFilter> transientFaultFilters)
        {
            if (transientFaultFilters == null)
                transientFaultFilters = new List<ITransientFaultFilter>(capacity: 0);

            var result = default(TResult);

            List<Exception> failedAttempts = new List<Exception>(capacity: maxRetryAttempts);

            var filters = transientFaultFilters.EmptyIfNull().ToArray();

            bool success = false;

            while (!success && maxRetryAttempts-- > 0)
            {
                try
                {
                    result = func();
                    success = true;
                }
                catch (Exception ex)
                {
                    if (transientFaultFilters.Count == 0)
                        throw;

                    for (int i = 0; i < transientFaultFilters.Count; i++)
                    {
                        var filter = transientFaultFilters[i];

                        if (!filter.IsTransientFault(ex))
                            throw;

                        failedAttempts.Add(ex);

                        TimeSpan retryDelay =
                            TimeSpan.FromMilliseconds(
                                Rand.Next(minDelayInMiliseconds,
                                maxDelayInMiliseconds));

                        Thread.Sleep(retryDelay);
                    }
                }
            }

            if (!success)
            {
                throw new AggregateException(
                    "Operation failed to execute {0} times."
                    .FormatWith(
                    failedAttempts.Count), 
                    failedAttempts.Distinct(new ExceptionEqualityComparer()).ToArray());
            }

            return result;
        }
    }

    class ExceptionEqualityComparer : IEqualityComparer<Exception>
    {
        public bool Equals(Exception x, Exception y)
        {
            if (x == null || y == null)
                return false;

            if (x.GetType() != y.GetType())
                return false;

            if (x.Message != y.Message)
                return false;

            if (x.StackTrace != y.StackTrace)
                return false;

            return true;
        }

        public int GetHashCode(Exception obj)
        {
            if (obj == null)
                return -1;

            unchecked
            {
                int hash = 17;

                if (obj.Message != null)
                    hash = hash * 23 + obj.Message.GetHashCode();

                if (obj.StackTrace != null)
                    hash = hash * 23 + obj.StackTrace.GetHashCode();

                return hash;
            }
        }
    }


    
