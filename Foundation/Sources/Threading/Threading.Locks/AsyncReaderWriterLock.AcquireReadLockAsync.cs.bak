using SquaredInfinity.Disposables;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace SquaredInfinity.Threading.Locks
{
    public partial class AsyncReaderWriterLock
    {
        #region Acquire Read Lock (overloads)

        public async Task<ILockAcquisition> AcquireReadLockAsync()
            => await  AcquireReadLockAsync(AsyncOptions.Default);
        public async Task<ILockAcquisition> AcquireReadLockAsync(CancellationToken ct)
            => await AcquireReadLockAsync(new AsyncOptions(ct));
        public async Task<ILockAcquisition> AcquireReadLockAsync(int millisecondsTimeout)
            => await AcquireReadLockAsync(new AsyncOptions(millisecondsTimeout));
        public async Task<ILockAcquisition> AcquireReadLockAsync(int millisecondsTimeout, CancellationToken ct)
            => await AcquireReadLockAsync(new AsyncOptions(millisecondsTimeout, ct));
        public async Task<ILockAcquisition> AcquireReadLockAsync(TimeSpan timeout)
            => await AcquireReadLockAsync(new AsyncOptions(timeout));
        public async Task<ILockAcquisition> AcquireReadLockAsync(TimeSpan timeout, CancellationToken ct)
            => await AcquireReadLockAsync(new AsyncOptions(timeout, ct));

        #endregion

        public async Task<ILockAcquisition> AcquireReadLockAsync(AsyncOptions options)
        {
            if (options.MillisecondsTimeout == 0)
                return _FailedLockAcquisition.Instance;

            if (IsLockAcquisitionRecursive())
                return new _DummyLockAcquisition();

            using (var l = await InternalLock.AcquireWriteLockAsync(options).ConfigureAwait(options.ContinueOnCapturedContext))
            {
                if (!l.IsLockHeld)
                    return _FailedLockAcquisition.Instance;

                var ownerThreadId = Environment.CurrentManagedThreadId;

                // we are not in write lock and there is no pending writer
                // just acquire another read lock
                if (_currentState >= STATE_NOLOCK && _waitingWriters.Count == 0)
                {
                    if (CompositeLock == null)
                    {
                        // no children to lock, we can just grant reader-lock and return
                        _readOwnerThreadIds.Add(ownerThreadId);
                        _currentState++;
                        return new _ReadLockAcquisition(this, ownerThreadId, null);
                    }
                    else
                    {
                        // there might be children
                        // try locking them now

                        try
                        {
                            // try to lock children
                            var children_acquisition = 
                                await 
                                CompositeLock
                                .LockChildrenAsync(LockType.Read, options)
                                .ConfigureAwait(options.ContinueOnCapturedContext);

                            if (!children_acquisition.IsLockHeld)
                            {
                                // couldn't acquire children, return failure
                                children_acquisition.Dispose();
                                return new _FailedLockAcquisition();
                            }

                            _readOwnerThreadIds.Add(ownerThreadId);
                            _currentState++;
                            return
                                new _ReadLockAcquisition(owner: this, ownerThreadId: ownerThreadId, disposeWhenDone: children_acquisition);
                        }
                        catch
                        {
                            throw;
                        }
                    }
                }
                else
                {
                    // we are in write mode
                    // or there is a pending writer waiting
                    // add this reader to waiting readers list

                    var completion_source = new TaskCompletionSource<ILockAcquisition>();
                    _waitingReaders.Enqueue(
                        new _Waiter(
                            completion_source, 
                            Environment.CurrentManagedThreadId,
                            options.MillisecondsTimeout, 
                            options.CancellationToken));

                    l.Dispose();

                    return await completion_source.Task;
                }
            }
        }
    }
}
