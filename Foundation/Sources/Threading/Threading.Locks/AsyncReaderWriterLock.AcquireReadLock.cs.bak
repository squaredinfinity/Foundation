using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace SquaredInfinity.Threading.Locks
{
    public partial class AsyncReaderWriterLock
    {
        #region Acquire Read Lock (overloads)

        public ILockAcquisition AcquireReadLock()
            => AcquireReadLock(SyncOptions.Default);
        public ILockAcquisition AcquireReadLock(CancellationToken ct)
            => AcquireReadLock(new SyncOptions(ct));
        public ILockAcquisition AcquireReadLock(int millisecondsTimeout)
            => AcquireReadLock(new SyncOptions(millisecondsTimeout));
        public ILockAcquisition AcquireReadLock(int millisecondsTimeout, CancellationToken ct)
            => AcquireReadLock(new SyncOptions(millisecondsTimeout, ct));
        public ILockAcquisition AcquireReadLock(TimeSpan timeout)
            => AcquireReadLock(new SyncOptions(timeout));
        public ILockAcquisition AcquireReadLock(TimeSpan timeout, CancellationToken ct)
            => AcquireReadLock(new SyncOptions(timeout, ct));

        #endregion 

        public ILockAcquisition AcquireReadLock(SyncOptions options)
        {
            if (options.MillisecondsTimeout == 0)
                return _FailedLockAcquisition.Instance;

            if (IsLockAcquisitionRecursive())
                return new _DummyLockAcquisition();

            using (var l = InternalLock.AcquireWriteLock(options))
            {
                if (!l.IsLockHeld)
                    return _FailedLockAcquisition.Instance;

                return AcquireReadLock_NOLOCK(l, Environment.CurrentManagedThreadId, options);
            }
        }

        ILockAcquisition AcquireReadLock_NOLOCK(ILockAcquisition internalLockAcquisition, int ownerThreadId, SyncOptions options)
        {
            if (options.MillisecondsTimeout == 0)
                return _FailedLockAcquisition.Instance;

            if (IsLockAcquisitionRecursive())
                return new _DummyLockAcquisition();

			// to acquire read lock
			// write lock must not be held (but read can)
			// and there must not be any waiting writers
            if (_currentState >= STATE_NOLOCK && _waitingWriters.Count == 0)
            {
                // we are not in write or read lock and there is no waiting writer
                // just acquire another read lock

                if (CompositeLock == null)
                {
                    // no children to lock, we can just grant reader-lock and return
                    _readOwnerThreadIds.Add(ownerThreadId);
                    _currentState++;
                    return new _ReadLockAcquisition(this, ownerThreadId, null);
                }
                else
                {
                    // there might be children
                    // try locking them now

                    try
                    {
                        // try to lock children
                        var children_acquisition =
                            CompositeLock
                            .LockChildren(LockType.Read, options);

                        if (!children_acquisition.IsLockHeld)
                        {
                            // couldn't acquire children, return failure
                            
                            children_acquisition.Dispose();
                            return new _FailedLockAcquisition();
                        }

                        _readOwnerThreadIds.Add(ownerThreadId);
                        _currentState++;
                        return
                            new _ReadLockAcquisition(owner: this, ownerThreadId: ownerThreadId, disposeWhenDone: children_acquisition);
                    }
                    catch
                    {
                        _readOwnerThreadIds.Remove(Environment.CurrentManagedThreadId);
                        throw;
                    }
                }
            }
            else
            {
                // we are in write mode
                // or there is a pending writer waiting
                // add this reader to waiting readers list

                var completion_source = new TaskCompletionSource<ILockAcquisition>();
                _waitingReaders.Enqueue(
                    new _Waiter(
                        completion_source, 
                        Environment.CurrentManagedThreadId, 
                        options.MillisecondsTimeout, 
                        options.CancellationToken));

                // unlock this instance
                internalLockAcquisition.Dispose();

                // block this thread until task completes
                if (completion_source.Task.Wait(options.MillisecondsTimeout, options.CancellationToken))
                    return completion_source.Task.Result;
                else
                    return _FailedLockAcquisition.Instance;
            }
        }
    }
}
